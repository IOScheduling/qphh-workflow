#pragma once


#ifndef FRAME_CLASSANDVARDEFINE_H
#include <vector>
#include <string>
#include <set>
#include <map>
#include <list>
#include <stack>
#define FRAME_CLASSANDVARDEFINE_H
using namespace std;

class vfile {
public:
    string FileName;     //file name
    int source;          //the source of file, -1:from the shared server; i: from task i
    double size;         //the size of file
};

class Task {
public:
    double length;
    vector<int> ElgRsc;
    vector<int> parents;
    vector<int> children;
    vector<vfile> IFile;
    vector<vfile> OFile;
    double IFileSizeSum = 0.0;             //the size of all input files need to transfer including ExternalInputFileSizeSum
    double OrignalInputFileSizeSum = 0.0;  //the size of all input files
    double ExternalInputFileSizeSum = 0.0; //the size of all input files which are not generated by their parent tasks
    double OFileSizeSum = 0.0;             //the size of all output files
    //理论上IFileSizeSum=OrignalInputFileSizeSum;
    //但如果两个父任务有输出文件名相同的文件而且子任务又有该文件名的输入文件，则IFileSizeSum>OrignalInputFileSizeSum;
};

class Resource {
public:
    int Hostid;                // 主机ID，表示资源所属的主机
    vector<int> ElgTsk;        // 可执行的任务列表，存储该资源可以执行的任务ID
    double pc;                 // 资源的处理能力 (processing capability)
    double bw;                 // 资源的带宽 (bandwidth)

    // 默认构造函数
    Resource() {

    };

    // 带参数的构造函数，用于初始化资源对象
    Resource(int hostId, double pc, double bw) {
        this->Hostid = hostId;  // 初始化主机ID
        this->pc = pc;          // 初始化处理能力
        this->bw = bw;          // 初始化带宽
    }
};

class HT {
public:
    vector<int> RscLstInHt; // 该主机内的资源列表，存储资源的ID
    double pc;              // 主机的处理能力 (processing capability)
    double bw;              // 主机的带宽 (bandwidth)

    // 带参数的构造函数，用于初始化主机对象
    HT(vector<int> RscLstInHt, double pc, double bw) {
        this->RscLstInHt = RscLstInHt;  // 初始化资源列表
        this->pc = pc;                  // 初始化处理能力
        this->bw = bw;                  // 初始化带宽
    }
};

class chromosome {
public:
    vector<int> RscAlcLst;       //resources allocation, task-to-resource mapping, (Match String)
    vector<int> TskSchLst;       //task scheduling order (Scheduling String)
    vector<double> Code_RK;
    vector<list<int>> Code_TD;
    vector<double> RscAlcPart;
    vector<double> TskSchPart;
    vector<double> VTskSchPart;
    vector<double> VRscAlcPart;
    vector<double> StartTime, EndTime;
    vector<pair<double, double>> HtUseTime;//使用主机的时间，<开始时间，结束时间>
    double MakeSpan;
    double EnergyConsumption;
    bool IsFrw;   //if IsFrw = true, RscAlcLst is Forward Topological Sort, otherwise, it is Backward Topological Sort;

    bool operator<(const chromosome& otherChrom) const {
        return this->EnergyConsumption + 1e-6 < otherChrom.EnergyConsumption;
    }
};

class chromosome_QPHH {
public:
    vector < vector<int>> VMList; //解表达  二维表示；每一维为VM1, VM2, ...,VMI
    vector<double> Code_RK;
    vector<list<int>> Code_TD;
    vector<double> RscAlcPart;
    vector<double> TskSchPart;
    vector<double> VTskSchPart;
    vector<double> VRscAlcPart;
    vector < vector<double>>  StartTime, EndTime;
    vector<pair<double, double>> HtUseTime;//使用主机的时间，<开始时间，结束时间>
    double MakeSpan;
    double EnergyConsumption;
    bool IsFrw;   //if IsFrw = true, RscAlcLst is Forward Topological Sort, otherwise, it is Backward Topological Sort;

    bool operator<(const chromosome& otherChrom) const {
        return this->EnergyConsumption + 1e-6 < otherChrom.EnergyConsumption;
    }

    pair<int, int> FindTaskPosition(int taskID) const {
        for (int i = 0; i < VMList.size(); ++i) {
            auto it = find(VMList[i].begin(), VMList[i].end(), taskID);
            if (it != VMList[i].end()) {
                return { i, distance(VMList[i].begin(), it) };
            }
        }
        return { -1, -1 }; // 任务未找到
    }
};

class ComConst {
public:
    int NumOfTsk;
    int NumOfRsc;
};

class Paramet_HGA {
public:
    int NumOfChromPerPop;
    double EliteRate;         //crossover rate(CrossoverRate)
    double MutationRate;      //mutation rate (MutationRate)
};

class Paramet_HPSO {
public:
    int NumOfChromPerPop;
    double InertiaWeight;
    double c1;
    double c2;
};

class Paramet_CGA {
public:
    int NumOfChromPerPop;
    double CrossoverRate;      //crossover rate(CrossoverRate)
    double MutationRate;       //mutation rate (MutationRate)
};

class Paramet_NGA {
public:
    int NumOfChromPerPop;
    double CrossoverRate;     //crossover rate
    double MutationRate;      //mutation rate
    double EliteRate;         //crossover rate
};

class Paramet_LWSGA {
public:
    int NumOfChromPerPop;
    double CrossoverRate;     //crossover rate(CrossoverRate)
};

class Paramet_TSEDA {
public:
    int NumOfChromPerPop;
    double theta1;
    double theta2;
    double fdhi;
    int NumOfImproveOfPop;
    double RunTimeRatioOfStg1;
};

class Paramet_ADBRKGA {
public:
    int NumOfChromPerPop;     //the number of chromosomes in each population
    double alpha;
    double beta;
    double BiasesRate;
    double ImmigrationRate;
    double ImprovementRate;
};

class Paramet_QPHH {
public:
    int NumOfChromPerPop;     //the number of chromosomes in each population
    double RunTimeRatioOfStg1;
};

class Experiment {
public:
    double popsizerate;
    int selectCount;
    double epslion;
    double gamma;
};





extern vector<Task> Tasks;
extern vector<Task> TaskO;
extern vector<int> Oid;
extern vector<int> Nid;
extern vector<vector<int>> TskLstInLvl; //task list (set) in each level;
extern vector<vector<double> > ParChildTranFileSizeSum;
extern vector<set<int>> Descendants;
extern vector<set<int>> Ancestors;
extern vector<int> LevelIdOfTask;
extern vector<Resource> Rscs;
extern ComConst comConst;
extern vector<HT> HstSet;
extern double ModelScale;
extern double SchTime;
extern Paramet_HGA Parameter_HGA;
extern Paramet_NGA Parameter_NGA;
extern Paramet_LWSGA Parameter_LWSGA;
extern Paramet_CGA Parameter_CGA;
extern Paramet_HPSO Parameter_HPSO;
extern Paramet_TSEDA Parameter_TSEDA;
extern Paramet_ADBRKGA Parameter_ADBRKGA;
extern Paramet_QPHH Parameter_QPHH;


#endif //FRAME_CLASSANDVARDEFINE_H
